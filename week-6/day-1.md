# JS 第 6 周第 1 天

## 1. 闭包

### 1.1. 如何访问其他函数内部数据？

### 1.2. 闭包概念

> ***闭包就是指 一个可以访问其他函数内部数据的函数。***

### 1.3. 闭包特点

- 函数嵌套函数；outer函数和inner函数
- 内部函数可以使用外部函数的内部变量（形参）
- 内部inner函数 是 外部outer函数的返回值
- 函数中的局部变量在外部是不能被引用（保护函数内的变量安全）
- 外层函数一旦执行，就会创建新的闭包。而不同闭包之间的数据是独立的。

```js
function outer(m){
    var n = Math.random();

    function inner(){
        // 使用外部函数的变量
        return m + n;
    }
    
    return inner;
}

// function outer() {
//   var n = Math.random();

//   return function() {
//     return n;
//   };
// }

 function outer() {
     var n, m;
     n = Math.random();
     m = { name: 'm' };

     return {
         getN: function() {
             return n;
         },
         getM: function() {
             return m;
         }
     };
 }
```

### 1.4. 闭包优缺点

- 避免全局变量污染
- 将函数内部变量的值始终保存在内存中（缓存）
- 通过保护变量的安全实现 JS 私有属性和私有方法（不能被外部访问）
- 缺点：使用闭包，会增大内存的开销；如果滥用闭包，就会有可能造成内存泄漏的危险。

> **内存泄漏**： 计算机的内存被一点一点占满，从而不能在定义其他变量、数据...。这种现象叫做 “内存泄漏”。
>
> **内存溢出**： 存储数据所需要的内存空间，超过计算机所剩下的内存空间。此时在开辟内存时，就会有溢出。因此这样的现象被叫做“内存溢出”；

## 2. 闭包缓存原理

> 内存管理：所有的高级语言中，都会有一个名为：GC 对象。由它来负责程序运行的内存管理。
>
> - 当需要创建变量时。开辟一定的内存空间来存储数据。（开辟）
> - 在合适的时机下，将那些不在使用的数据所占用内存释放掉。（回收）
>
> **GC工作流程**：GC工作前，内存中会有两个内存空间；分别叫做 `from`和 `to`。
>
> - 所有定义的数据、变量等，先在from内存空间去开辟，
> - 当from空间被占满时，GC出来工作。
> - 将from空间的数据，移植到to空间去，
> - GC造访to空间中的所有数据，查看是否已没有任何变量，对象使用了，
> - 如果是的话，那么就将其所占用内存释放的（回收）
> - 最后将在to空间中没有回收的数据，在移植会from空间。
> - 直到from空间再次被占满，如此反复。

### 2.1. 垃圾回收机制

- 引用计数法：当 某一数据被创建时，此时计数 为 0.（问题：循环引用）
  - 当有某一变量或对象 使用了该数据，计数+1；
  - 当某一变量或对象 不在使用该数据，计数-1；
  - 当GC造访时，如果计数为0，就表示该数据没有被使用。因此要回收其所占内存。
- 标记清除法：如果根root（window）出发，找不到任何一条路径可以到达某一数据（变量），那么说明该变量（数据）没有任何人使用。此时该数据被标记为“可清除”。
  - 当GC造访时，如果该数据被标记为“可清除”，那么就要回收其所占内存。
- 异步标记清除法：利用多线程的优势，来解决传统标记清除法的性能问题。

## 3. 闭包应用

- 缓存
- setTimeout 等传参问题
- 私有变量
- 模块化（块级作用域）IIFE

## 4. 终极面试题

```js
function showBiBao() {
  for (var i = 0; i < 5; i++) {
    setTimeout(function timer() {
      console.log(i);
    }, 1000);
  }
  console.log(i);
}
// 会输出什么
showBiBao();
```

```js
function func(n, o) {
    console.log(o);
    return {
        func: function(m) {
            return func(m, n);
        }
    };
}

var a = func(0);
a.func(1);
a.func(2);
a.func(3);

var b = func(0)
.func(1)
.func(2)
.func(3);

var c = func(0).func(1);
c.func(2);
c.func(3);
```
